- [ ] Separate `infer-arity` into `infer-arity` and `parcial-application`
- [ ] Benchmark per folder
- [ ] Create different fibonacci functions for each benchmark
- [ ] behavior as N goes higher
- [ ] Fix single argument case for non primitive argument
- [ ] Fix lint task
- [ ] better benchmark output
- [ ] `benchmark:solo` task
- [ ] Inline code
- [ ] Google Closure compiler to optimize code
- [ ] Real inline code
- [ ] Implement "optimize after fist run" strategy
- [ ] Implement "explicit" strategy
- [ ] Implement "single primitive" strategy
- [ ] Implement "single non-primitive" strategy
- [ ] 100% coverage

## Steps
- Inline
- Explicit strategy
- NodeJS optimizations
- Google Closure compile

---

- bind with args
- has prop
  - reflect api
  - in
  - hasOwnProperty
  - !== undefined

---

has !== undefined is super slow

analise do algoritmo fibonacci

https://blog.ghaiklor.com/tracing-de-optimizations-in-nodejs-2ba16900fc6f#.r6hi36wku
