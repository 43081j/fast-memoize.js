- [ ] Separate `infer-arity` into `infer-arity` and `parcial-application`
- [ ] Benchmark per folder
- [ ] Create different fibonacci functions for each benchmark
- [ ] behavior as N goes higher
- [ ] Fix single argument case for non primitive argument
- [ ] Fix lint task
- [ ] better benchmark output
- [ ] `benchmark:solo` task
- [ ] Inline code
- [ ] Google Closure compiler to optimize code
- [ ] Real inline code
- [ ] Implement "optimize after fist run" strategy
- [ ] Implement "explicit" strategy
- [ ] Implement "single primitive" strategy
- [ ] Implement "single non-primitive" strategy
- [ ] 100% coverage
- [ ] function generator

## Steps
- Inline
- Explicit strategy
- NodeJS optimizations
  - instrospection
- Enable turbo
- web tracing framework

---

- bind with args
- has prop
  - reflect api
  - in
  - hasOwnProperty
  - !== undefined

---

has !== undefined is super slow

analise do algoritmo fibonacci

https://blog.ghaiklor.com/tracing-de-optimizations-in-nodejs-2ba16900fc6f#.r6hi36wku
https://www.npmjs.com/package/v8-natives
http://blog.trevnorris.com/2013/07/measuring-node-performance-part-1.html
http://mrale.ph/s3/nodecamp.eu/#1
https://floitsch.blogspot.com.br/2012/03/optimizing-for-v8-introduction.html


https://github.com/petkaantonov/bluebird/wiki/Optimization-killers
https://www.npmjs.com/package/v8-natives
--turbo
https://gist.github.com/kevincennis/0cd2138c78a07412ef21
